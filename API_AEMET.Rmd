---
title: "Consulta de datos necesarios de AEMET"
author: "Marta Ferrer Cuesta"
date: "1/7/2020"
output: html_document
---

#### Librerías

```{r librerias, warning = FALSE, message = FALSE}

# install.packages("httr")
# install.packages("jsonlite")
# install.packages("urltools")
# install.packages("tidyjson")
# install.packages("leaflet")
# install.packages("Rcpp")

require("httr")
require("jsonlite")
library(urltools)
library("tidyverse")
library(tidyjson)
library(leaflet)
library(Rcpp)
library(kableExtra)
library(lubridate)

```

#### Variables

```{r variables}

api_key <-"eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJtYXJ0YWZlY3VAZ21haWwuY29tIiwianRpIjoiYzlmMWRkMmUtNjE2YS00ZGNmLWE5YzItNzc1ODg3YzlkZTdmIiwiaXNzIjoiQUVNRVQiLCJpYXQiOjE1ODUzMDUzNDUsInVzZXJJZCI6ImM5ZjFkZDJlLTYxNmEtNGRjZi1hOWMyLTc3NTg4N2M5ZGU3ZiIsInJvbGUiOiIifQ.p2Ka71le5XedoJE8iIYIKVh-wyOvAOYEszH9OcwoQxc"

url_base <- "https://opendata.aemet.es/opendata/api"

```


## Funciones auxiliares

### Consulta genérica

Esta función nos permite encapsular la conexión a la api para la descarga de los datos.

Los parámetros que recibe son:

* **url_base**: url base para todas las urls de descarga.
* **url**: Fragmento de la url para la descarga.
* **api_key**: Clave necesaria para la descarga de los datos (se crea en [AEMET](https://opendata.aemet.es/centrodedescargas/altaUsuario?))
* **id**: parámetros para realizar la consulta (puede no ser necesario)

Devuelve la respuesta con los datos descargados en la consulta.

```{r get}

get_response <- function(url_base, url = "", api_key, id = ""){
  
  call <- paste(url_base, url, id, sep = "/")
  call <- param_set(call, key = "api_key", value = api_key)
  
  response <- GET(call)
  
  # Si obtenemos un json, en el caso de AEMET, significa que en el json devuelto está la siguiente url que debemos consultar para obtener los datos
  
  if(http_type(response) == "application/json"){
    
    resp_text <- content(response, "text")
    body <- fromJSON(resp_text, flatten = TRUE)
    response <- get_response(body$datos, api_key = api_key)
    
  }
  
  # Comprobar si la petición es errónea y en caso afirmativo devolver un mensaje 
  
  if(http_error(response)){
    
    resp_text <- content(response, "text")
    body <- fromJSON(resp_text, flatten = TRUE)
    
    sprintf(
      "GitHub API request failed [%s]\n%s\n", 
      status_code(response),
      body$message
    )
  }
  
  response
}

```


Table: Equivalencias Latitud y Longitud

**Latitud** |  **Longitud** | **Latitud** |  **Longitud** |
----------------------| ----------------------|----------------------| ----------------------|
0º a 90º | 0º a 180º | N | E
0º a 90º | 0º a -180º | N | O
0º a -90º | 0º a 180º | S | E
0º a -90º | 0º a -180º | S | O

### Pasar de grados, minutos y segundos a grados decimales

```{r lat_lon_dec}
latitud_longitud_decimal <- function(grados, minutos, segundos){
  
  lat_lon <- grados + (1/60)*minutos + (1/3600)*segundos

}

```


### Cálculo de la distancia entre dos puntos

Cada punto viene dado por las coordenadas de latitud y longitud. Se han elaborado dos funciones para realizar este cálculo.

- Distancia Manhattan:

$$Distancia = \sum abs(x-y)$$

- Distancia euclídea:

$$Distancia =  \sqrt{\sum(x-y)^2}$$

```{r distancia}

distancia <- function(lat1, lon1, lat2, lon2, distancia = "euclidea"){
   
  if(distancia == "euclidea"){
    
    dist <- sqrt((lat1 - lat2)**2+ (lon1 -lon2)**2)
    
  }else if(distancia == "manhattan"){
    
    dist <- abs(lat1 - lat2)+ abs(lon1 -lon2)
  }
  
  dist 
}

```

### Radiación extraterrestre diaria

$$Gh_0 = \frac{24}{\pi} K_{solar}  E_0 (w_s sin(\delta) sin(\phi) + cos(\delta)cos(\phi)sin(w_s))$$

```{r gh}
gh_diaria <- function(E0, ws, decl, lat){
  
  k_solar <- 1361 #W/m^2
  
  gh <- 24/pi * k_solar * E0 * (ws* sin(decl) * sin(lat) + cos(decl) * cos(lat) * sin(ws))
}

```

### Función auxiliar para la consulta de predicción horaria

Al realizar la consulta de la predicción horaria para un municipio, los datos devueltos están en un dataframe con muchos niveles de anidamiento.

Por un lado, aparecen datos horarios y, por otro, aparecen datos para un período horario de 6 horas (02-08, 08-14, 14-20, 20-02) que son las probabilidades de precipitación, nieve y tormenta. Para que no se mezclen estos datos se devuelve una lista con dos dataframes (uno de valores horarios y otro con valores para períodos horarios).

```{r desanidamiento}

# Desanidamiento de la predicción horaria por municipios

desanidamiento <- function(prediccion_horaria_df) {
  
  prediccion_dia <- prediccion_horaria_df$prediccion.dia[[1]]
  
  prediccion_horaria_df <- prediccion_horaria_df %>% unnest(prediccion.dia)
  
  col_horarias <- c("estadoCielo", "precipitacion", "nieve", "temperatura", "sensTermica", "humedadRelativa", "vientoAndRachaMax")
  col_prob <- c("probPrecipitacion", "probTormenta", "probNieve","vientoAndRachaMax")
  
  prediccion_cols_horarias <- prediccion_horaria_df %>% select(!col_prob)
  prediccion_cols_prob <- prediccion_horaria_df %>% select(!col_horarias)
  
  
  prediccion_cols_horarias <- prediccion_cols_horarias %>% 
    
                              unnest(estadoCielo, 
                                     precipitacion, 
                                     nieve, 
                                     temperatura, 
                                     sensTermica, 
                                     humedadRelativa, 
                                     names_sep = ".")
  
  prediccion_cols_prob <- prediccion_cols_prob %>% 
    
                            unnest(probPrecipitacion, 
                                   probNieve, 
                                   probTormenta, 
                                   names_sep = ".")
  
  df_viento <- rbind(prediccion_dia$vientoAndRachaMax[[1]], 
                     prediccion_dia$vientoAndRachaMax[[2]],
                     prediccion_dia$vientoAndRachaMax[[3]])
  
  filas_viento <- seq(2, 96, by = 2)
  value <- df_viento$value[filas_viento]
  
  filas <- seq(1,96, by = 2)
  
  df_viento <- cbind(df_viento[filas, 1:3], value)
  
  colnames(df_viento) <- paste("viento", colnames(df_viento), sep = ".")
  df_viento$viento.velocidad <- unlist(df_viento$viento.velocidad)
  df_viento$viento.direccion <- unlist(df_viento$viento.direccion)
  
  prediccion_cols_horarias <- cbind(prediccion_cols_horarias, df_viento)
  
  list ( columnas_intervalo = prediccion_cols_prob, 
         columnas_horas     = prediccion_cols_horarias)
}
```



## Funciones específicas de cada consulta a la API

### Municipios 

Consultar el listado de municipios para los que AEMET elabora las predicciones. Esta consulta sólo será necesario realizarla una vez y guardar el listado de los municipios una vez.

```{r get_municipios, eval = FALSE}

municipios_url <- "maestro/municipios"

get_municipios <- get_response(url_base, municipios_url, api_key)

municipios_text <- content(get_municipios, "text")

datos_municipios <- fromJSON(municipios_text, flatten = TRUE)

datos_municipios$id <- substr(datos_municipios$id, 3, 7) # Las consultas que requieren el id, requieren de                                                             la eliminación de la palabra "id"

write.csv(datos_municipios, "municipios.csv")

```

### Estaciones meteorológicas

Se consulta el listado de estaciones meteorológicas que ofrecen información de la observación convencional. Al igual que sucede con el listado de municipios, sólo será necesario realizar esta consulta una vez y almacenar el listado de estaciones meteorológicas.

En los datos que se obtienen directamente de la consulta, la latitud y longitud de cada estación vienen dados en grados, minutos y segundos en un tipo string. Para facilitar los futuros cálculos se han transformado las latitudes y longitudes a grados decimales.

Por otro lado, hay que tener en cuenta que hay estaciones que vienen con el indicativo (id de una estación) incorrecto y hay que corregirlo. Hasta el momento sólo se ha detectado un indicativo incorrecto.

```{r get_estaciones, eval = FALSE}

estaciones_url <- "valores/climatologicos/inventarioestaciones/todasestaciones"

get_estaciones <- get_response(url_base, estaciones_url, api_key = api_key)

estaciones_text <- content(get_estaciones, "text")

datos_estaciones_df <- fromJSON(estaciones_text, flatten = TRUE)



datos_estaciones_df <- datos_estaciones_df %>% 
                          mutate(grados_lat = as.numeric(substr(latitud, 1, 2)),
                                 minutos_lat = as.numeric(substr(latitud, 3, 4)),
                                 segundos_lat = as.numeric(substr(latitud, 5, 6)),
                                 orient_lat = substr(latitud,7,7),
                                 latitud_dec = latitud_longitud_decimal(grados_lat, 
                                                                        minutos_lat, 
                                                                        segundos_lat),
                                 
                                 grados_lon =  as.numeric(substr(longitud, 1, 2)),
                                 minutos_lon = as.numeric(substr(longitud, 3, 4)),
                                 segundos_lon = as.numeric(substr(longitud, 5, 6)),
                                 orient_lon = substr(longitud,7,7),
                                 longitud_dec = latitud_longitud_decimal(grados_lon, 
                                                                         minutos_lon, 
                                                                         segundos_lon))

estaciones_lat_W <- which(datos_estaciones_df$orient_lon == "W")
estaciones_lon_S <- which(datos_estaciones_df$orient_lon == "S")

datos_estaciones_df$longitud_dec[estaciones_lat_W] <- - datos_estaciones_df$longitud_dec[estaciones_lat_W] 
datos_estaciones_df$latitud_dec[estaciones_lon_S] <- - datos_estaciones_df$latitud_dec[estaciones_lon_S] 

# Corregir indicativo incorrecto
est <- which(datos_estaciones_df$indicativo == "4121C")

datos_estaciones_df$indicativo[est] <- "4121"

write.csv(datos_estaciones_df, "estaciones_meteorologicas.csv")

```

### Estaciones Radiación solar

Como sólo algunas estaciones de AEMET ofrecen datos de radiación solar el objetivo es obtener el indicativo de las estaciones que ofrecen radiación solar así como sus coordenadas (latitud y longitud) y almacenar estos datos para, posteriormente, poder localizar la estación más cercana al punto de interés a la hora de realizar los cálculos. 

No todas las estaciones del listado de estaciones que proporciona la consulta de estaciones que ofrecen información de observación meteorológica ofrecen también información de radiación solar. Al realizar una consulta de los datos de radiación solar, además de la información recogida de la radiación se proporciona la ciudad y el indicativo de la estación que elabora los datos, con esta información y la que ya se dispone del listado de estaciones meteorológicas se elaborará la nueva información.

Para elaborar el listado, realizamos un left_join de las estaciones de radiación solar junto a su indicativo, con el listado de estaciones meteorológicas. Tras este join se observó que la estación de Málaga en la descarga de datos de radiación tiene mal puesto el indicativo, por lo que es necesario corregirlo.

Por otro lado, no todas las estaciones que ofrecen datos de radiación aparecen en el listado de estaciones meteorológicas que ofrecen datos de observación convencional. La solución empleada ha sido localizar en AEMET los datos de latitud y longitud de estas estaciones.

Todo este procedimiento para obtener este nuevo listado sólo será necesario realizarlo una vez.


```{r estaciones_radiacion, warning= FALSE, eval = FALSE}

radiacion_url <- "red/especial/radiacion"

get_radiacion <- get_response(url_base, radiacion_url, api_key)
  
radiacion_text <- content(get_radiacion, "text")

datos_rad <- substring(radiacion_text, 32)

csv_rad <- read_delim(datos_rad, delim =  ";")

malaga <- which(csv_rad$Estación == "Málaga")

csv_rad$Indicativo[malaga] <- paste0(csv_rad$Indicativo[malaga], "X")

estaciones_radiacion <- csv_rad %>% 
                          select(Estación, indicativo = Indicativo) %>%
                          left_join(datos_estaciones_df, by = "indicativo")

# Datos completados con:
# http://www.aemet.es/es/eltiempo/observacion/radiacion/ozono?l=zaragoza&f=ozono
# http://www.aemet.es/es/eltiempo/observacion/radiacion/radiacion?l=maspalomas
# http://www.aemet.es/es/eltiempo/observacion/radiacion/radiacion?l=badajoz

zaragoza <- which(estaciones_radiacion$Estación == "Zaragoza")
maspalomas <- which(estaciones_radiacion$Estación == "Maspalomas")
badajoz <- which(estaciones_radiacion$Estación == "Badajoz")

columnas_na <- c(zaragoza, maspalomas, badajoz)

estaciones_radiacion$altitud[columnas_na] <- c( 258, 45, 175 )
estaciones_radiacion$latitud[columnas_na] <- c("413800N", "274529N", "385360N")

estaciones_radiacion$grados_lat[columnas_na] <- c(41, 27, 38)
estaciones_radiacion$minutos_lat[columnas_na] <- c(38, 45, 53)
estaciones_radiacion$segundos_lat[columnas_na] <- c(00, 29, 60)
estaciones_radiacion$orient_lat[columnas_na] <- c("N", "N", "N")
estaciones_radiacion$latitud_dec[columnas_na] <- c(latitud_longitud_decimal(41, 38, 00),
                                                   latitud_longitud_decimal(27, 45, 53),
                                                   latitud_longitud_decimal(38, 53, 60))

estaciones_radiacion$longitud[columnas_na] <- c("005256W", "153432W", "070046W")

estaciones_radiacion$grados_lon[columnas_na] <- c(00, 15, 07)
estaciones_radiacion$minutos_lon[columnas_na] <- c(52, 34, 00)
estaciones_radiacion$segundos_lon[columnas_na] <- c(56, 32, 46)
estaciones_radiacion$orient_lon[columnas_na] <- c("W", "W", "W")
estaciones_radiacion$longitud_dec[columnas_na] <- c(-latitud_longitud_decimal(00, 52, 56),
                                                    -latitud_longitud_decimal(15, 34 ,32),
                                                    -latitud_longitud_decimal(07, 00, 46))


write.csv(estaciones_radiacion, "estaciones_radiacion.csv")

```

### Observación convencional

Consulta para obtener la observación convencional proporcionando el indicativo de la estación deseada. Esta información se renueva cada hora.

Se devuelve un dataframe con la información. El nombre del csv en el que se guarda esta información será: "observacion_convencional_id_(id de la estacion)_(fecha en el momento de la consulta)_(hora)h.csv".

```{r}

observacion_convencional <- function(base, observacion_convencional, api_key, idema) {
  
  get_observacion_convencional <- get_response(base, observacion_convencional, api_key, id = idema)
  observacion_text <- content(get_observacion_convencional, "text")
  
  obs_convencional_df <- fromJSON(observacion_text, flatten = TRUE)
  
  fecha <- as.character(Sys.Date())
  hora <- paste0(format(Sys.time(), "%H"),"h")
  
  nombre_csv <- paste("observacion_convencional","id", idema, fecha, hora, sep = "_")
  nombre_csv <- paste0(nombre_csv,".csv")
  write.csv(obs_convencional_df, file = nombre_csv, row.names = FALSE)
  
  obs_convencional_df
}

```


### Radiación solar

Consulta para la obtención de información de radiación solar. Devuelve todos los datos de radiación de todas las estaciones que ofrecen este tipo de información. Esta información se renueva una vez al día, por lo que sólo será necesario realizar esta consulta una vez al día.

Se devuelve un dataframe con toda la información del día anterior. El nombre del csv en el que se guarda esta información será: "radiacion_solar_(fecha del día anterior).csv".

```{r}

radiacion <- function(base, radiacion, api_key) {
  
  get_radiacion <- get_response(base, radiacion, api_key)
  
  radiacion_text <- content(get_radiacion, "text")
  
  datos_rad <- substring(radiacion_text, 32)
  
  csv_rad <- read_delim(datos_rad, delim =  ";")
  
  csv_rad$Indicativo[malaga] <- paste0(csv_rad$Indicativo[malaga], "X")
  
  fecha <- as.character(Sys.Date()-1)
  
  nombre_csv <- paste("radiacion_solar", fecha, sep = "_")
  nombre_csv <- paste0(nombre_csv,".csv")
  write.csv(csv_rad, file = nombre_csv, row.names = FALSE)
  
  csv_rad
}

```

### Predicción horaria

Consulta para la predicción horaria. Para realizar esta consulta es necesario proporcionar el código del municipio. Esta información se elabora 4 veces al día. 

Recordar que esta consulta devuelve una lista con dos dataframes (columnas_intervalo y columnas_horarias). Cada dataframe se guardará en un csv diferente, para la información horaria en "prediccion_horaria_id_(id del municipio)_(fecha del día que se elabora la información)_(hora)h.csv", y para la información en intervalo en "prediccion_intervalo_id_(id del municipio)_(fecha del día que se elabora la información)_(hora)h.csv"

```{r}

prediccion_horaria <- function(base, prediccion_horaria_url, api_key, idmun) {
  
  get_pred <- get_response(base, prediccion_horaria_url, api_key, id = idmun)
  pred_text <- content(get_pred, "text")
  
  prediccion_horaria_df <- fromJSON(pred_text, flatten = TRUE)
  
  prediccion <- desanidamiento(prediccion_horaria_df)
  
  fecha <- as.character(Sys.Date())
  hora <- paste0(format(Sys.time(), "%H"),"h")
  
  # Primer df
  nombre_csv1 <- paste("prediccion_horaria","id", idmun, fecha, hora, sep = "_")
  nombre_csv1 <- paste0(nombre_csv1,".csv")
  
  write.csv(prediccion$columnas_horas, file = nombre_csv1, row.names = FALSE)
  
  # Segundo df
  nombre_csv2 <- paste("prediccion_intervalo","id", idmun, fecha, hora, sep = "_")
  nombre_csv2 <- paste0(nombre_csv2,".csv")
  
  write.csv(prediccion$columnas_intervalo, file = nombre_csv2, row.names = FALSE)
  
  obs_convencional_df
  
  prediccion
}

```

## Funciones para extraer una observación para el sistema experto

- Temperatura diaria
- Precipitación diaria
- humedad relativa de 9 a 12 y de 12 a 15
- temperatura de 9 a 12 y de 12 a 15
- Predicción de temperatura de 9 a 12 y de 12 a 15
- Predicción de humedad relativa de 9 a 12 y de 12 a 15
- Predicción de nubosidad de 9 a 12 y de 12 a 15

* Destacar que estas funciones son para extraer los datos deseados una vez estén en un documento csv del servidor.

### Extracción de los datos de observacion convencional

Teóricamente, en AEMET los datos de observación convencional de las últimas 24 horas se renuevan cada hora añadiendo los valores recogidos durante la hora anterior. Si así fuera, a las 00h de cada día tendríamos los valores registrados para cada hora del día anterior; como esto no es siempre así, se ha optado por combinar los datos recogidos a dos horas diferentes para poder obtener los datos de un día completo sin problemas.

En el servidor debería haber un script que ejecutara las consultas necesarias a AEMET a las horas que se estimen convenientes para recoger cada tipo de dato.

```{r}

observacion_conv_df <- function(id_estacion, fecha, hora1, hora2) {
  
  ayer <- as.character(as.Date(fecha) - 1)
  
  obs_conv_hora1 <- paste("observacion_convencional","id", id_estacion, fecha, hora1, sep = "_")
  obs_conv_hora1 <- paste0("AEMET/", obs_conv_hora1,".csv")
  
  obs_conv_hora1_df <- read_csv(obs_conv_hora1)
  
  obs_conv_hora2 <- paste("observacion_convencional","id", id_estacion, fecha, hora2, sep = "_")
  obs_conv_hora2 <- paste0("AEMET/", obs_conv_hora2,".csv")
  
  obs_conv_hora2_df <- read_csv(obs_conv_hora2)
  
  obs_conv_hora1_df <- obs_conv_hora1_df %>% 
    mutate(dia = as.Date(fint)) %>%
    filter(dia == ayer)
  
  
  obs_conv_hora2_df <- obs_conv_hora2_df %>% 
    mutate(dia = as.Date(fint)) %>%
    filter(dia == ayer)
  
  obs_dia_df <- merge.data.frame(obs_conv_hora1_df, obs_conv_hora2_df, by = colnames(obs_conv_hora1_df), all =  TRUE) %>%
    mutate(hora = hour(fint))
  
  obs_dia_df
  
}

```

### Extracción de los datos de radiación

Se extraen los datos de radiacion global del municipio indicado y se pasan a Wh, ya que serán las unidades que empleemos. En AEMET la unidad para estos datos es 10 *KJ/m^2.

```{r}
rglobal_df <- function(id_estacion, ayer) {
  
  rad <- paste("radiacion_solar", ayer, sep = "_")
  rad <- paste0("AEMET/", rad, ".csv")
  
  rad_df <- read_csv(rad)
  
  rad_df <- rad_df %>% filter(Indicativo == id_estacion)
  
  horas <- c("Tipo", as.character(5:20), "SUMA")
  rad_gl <- rad_df %>% select(all_of(horas))
  
  # 1 wh = 3.6 kJ
  
  rad_gl[1, 2:ncol(rad_gl)] <- rad_gl[1, 2:ncol(rad_gl)] *10/3.6 #Pasar los datos a Wh
  
  rad_gl
}
```

### Extracción de los datos de predicción

Serán necesarios los datos de predicción de temperatura, humedad relativa y estado del cielo.

```{r}
prediccion_horas_df <- function(id_municipio, fecha, hora) {
  
  pred_horas <- paste("prediccion_horaria","id", id_municipio, fecha, hora, sep = "_")
  pred_horas <- paste0("AEMET/", pred_horas,".csv")
  
  pred_horas_df <- read_csv(pred_horas)
  
  pred_horas_df <- pred_horas_df %>%
    select(starts_with("estadoCielo"), 
           starts_with("temperatura."), 
           starts_with("humedadRelativa."),
           starts_with("viento."))
  
  pred_horas_df
}
```


## Ejemplo de funcionamiento

A continuación se muestra un ejemplo para datos de observación convencional y radiación extraídos para el 29 de junio y datos de predicciónes para el 30 de junio.

- Cargar datos de municipios, estaciones y radiación extraterrestre.

```{r}
  
municipios <- read.csv("municipios.csv")
estaciones <- read.csv("estaciones_meteorologicas.csv")
estaciones_rad <- read.csv("estaciones_radiacion.csv")

calculos_gh_df <- read.csv("calculos_radiacion_incidente_lat_38.729_lon_-3.962_incl_20_orient_0.csv")


```

Puntos del mapa:

```{r}
lat <- 38.729
lon <- - 3.962

m <- leaflet() %>%
  addTiles() %>%  # Añade por defecto los Tiles de  OpenStreetMap
  addMarkers(lng=lon, lat=lat, popup="Punto de interés")
m  # Imprime el mapa
```

Extraemos los municipios y estaciones meteorológicas más próximas al punto de interés mediante el cálculo de la mínima distancia al mismo.

```{r}

municipios2 <- municipios %>%                
                mutate(distancia = distancia(latitud_dec, longitud_dec, lat, lon, distancia = "manhattan")) %>%
                filter(distancia == min(distancia))

estaciones2 <- estaciones %>% 
                mutate(distancia = distancia(latitud_dec, longitud_dec, lat, lon)) %>%
                filter(distancia == min(distancia))

estaciones_rad2 <- estaciones_rad %>%  
                    mutate(distancia = distancia(latitud_dec, longitud_dec, lat, lon)) %>% 
                    filter(distancia == min(distancia))

```


- Municipio más cercano:

```{r echo = FALSE}
kable(municipios2)%>%
   kable_styling() %>%
   scroll_box(width = "900px", height = "160px")
```


- Estación de observación convencional más cercana:

```{r echo = FALSE}
kable(estaciones2)%>%
   kable_styling() %>%
   scroll_box(width = "900px", height = "140px")
```


- Estación de radiación solar más cercana:

```{r echo = FALSE}
kable(estaciones_rad2)%>%
   kable_styling() %>%
   scroll_box(width = "900px", height = "130px")
```

En el mapa podemos ver que Argamasilla de Calatrava es el municipio más cercano al punto introducido.


A continuación, se selecciona la información necesaria para elaborar la observación del modelo de predicción.

- Valores de observación convencional

```{r warning=FALSE, message=FALSE}

hoy <- "2020-06-30"

# Observación convencional-----------------

df_observacion <- observacion_conv_df(id_estacion = estaciones2$indicativo, fecha = hoy, hora1 = "00h", hora2 = "10h")

t_dia_previo <- mean(df_observacion$ta)

t_9_12_diaprevio <- df_observacion %>%
                      filter(hora %in% c(10:12))%>%
                      select(ta) %>% 
                      summarise(t_9_12_diaprevio = mean(ta, na.rm = T))%>%
                      unlist()


t_13_15_diaprevio <- df_observacion %>%
                      filter(hora %in% c(13:15))%>%
                      select(ta) %>% 
                      summarise(t_13_15_diaprevio = mean(ta, na.rm = T))%>%
                      unlist()

h8_diaprevio <- df_observacion %>%
                      filter(hora %in% c(10:12))%>%
                      select(hr) %>% 
                      summarise(hr_media = mean(hr, na.rm = T))%>%
                      unlist() / 100

h14_diaprevio <- df_observacion %>%
                      filter(hora %in% c(13:15))%>%
                      select(hr) %>% 
                      summarise(hr_media = mean(hr, na.rm = T))%>%
                      unlist() / 100

precipitac_dia_previo <- mean(df_observacion$prec)

humedad_diaria <- mean(df_observacion$hr) / 100

```

- Valores de predicción

```{r warning=FALSE, message=FALSE}
# Predicción horaria------------------------

df_prediccion_horaria <- prediccion_horas_df(id_municipio = municipios2$id, hoy, "10h")
df_prediccion_horaria$temperatura.periodo <- as.numeric(df_prediccion_horaria$temperatura.periodo)

Predicc_temp_day_C <- mean(df_prediccion_horaria$temperatura.value)

Predicc_Relative_humidity_day_0_1 <- mean(df_prediccion_horaria$humedadRelativa.value) / 100

Predicc_temp_10_11_12_C <- df_prediccion_horaria %>%
                        filter(temperatura.periodo %in% c(10:12))%>%
                        select(temperatura.value) %>% 
                        summarise(Predicc_temp_10_11_12_C = mean(temperatura.value, na.rm = T))%>%
                        unlist()

Predicc_temp_13_14_15_C <- df_prediccion_horaria %>%
                        filter(temperatura.periodo %in% c(13:15))%>%
                        select(temperatura.value) %>% 
                        summarise(Predicc_temp_10_11_12_C = mean(temperatura.value, na.rm = T))%>%
                        unlist()

Predicc_R_hum_10_11_12 <- df_prediccion_horaria %>%
                        filter(temperatura.periodo %in% c(10:12))%>%
                        select(humedadRelativa.value) %>% 
                        summarise(Predicc_R_hum_10_11_12 = mean(humedadRelativa.value, na.rm = T))%>%
                        unlist() / 100

Predicc_R_hum_13_14_15 <- df_prediccion_horaria %>%
                        filter(temperatura.periodo  %in% c(13:15))%>%
                        select(humedadRelativa.value) %>% 
                        summarise(Predicc_R_hum_13_14_15 = mean(humedadRelativa.value, na.rm = T))%>%
                        unlist() / 100

Predicc_cloudy_sky_day_0_1 <- NA

Predicc_cloudy_10_11_12 <- NA
Predicc_cloudy_13_14_15 <- NA

Predicc_temperatura_horaria <- df_prediccion_horaria$temperatura.value
  
Predicc_vviento_horario <- df_prediccion_horaria$viento.velocidad * 1000 # La velocidad del viento viene en Km/h, pasar a m/s para la entrada de la prod_fotovoltaica

```

- Radiación solar

```{r warning=FALSE, message=FALSE}
# Radiacion solar----------------------------

ayer <- as.character(as.Date(hoy) - 1)

df_r_global <- rglobal_df(estaciones_rad2$indicativo, ayer)

gd_previo <- df_r_global %>% 
              select(SUMA) %>% 
              unlist() 

# Radiación extraterrestre Gh----------------

gh_datos <- calculos_gh_df %>%
        filter(mes == 6, dia == 29) %>%
        select(declinacion_solar, excentricidad_diaria, w_sr)
         
gh <- gh_diaria(E0 = gh_datos$excentricidad_diaria,
                ws = gh_datos$w_sr,
                decl = gh_datos$declinacion_solar,
                lat = lat)

k_d_previo <- gd_previo/ gh #indice de transparencia (Kd) calculado
```

- Componer la observación

```{r}

observacion <- data.frame(gd_previo = gd_previo,
                          k_d_previo = k_d_previo,
                          t_9_12_diaprevio,
                          t_13_15_diaprevio,
                          h8_diaprevio,
                          h14_diaprevio,
                          t_dia_previo,
                          precipitac_dia_previo,
                          Predicc_temp_day_C,
                          Predicc_Relative_humidity_day_0_1,
                          Predicc_cloudy_sky_day_0_1,
                          Predicc_temp_10_11_12_C,
                          Predicc_cloudy_13_14_15,
                          Predicc_R_hum_10_11_12,
                          Predicc_R_hum_13_14_15,
                          Predicc_cloudy_10_11_12,
                          Predicc_cloudy_13_14_15)
```


```{r echo = FALSE}
rownames(observacion) <- 1
kable(observacion)%>%
   kable_styling() %>%
   scroll_box(width = "900px", height = "90px")
```

- Datos meteorológicos necesarios para el cálculo de la producción fotovoltaica (faltaría la radiación)

```{r}

prod_fv <- data.frame(Predicc_temperatura_horaria,
                      Predicc_vviento_horario)
```

```{r echo = FALSE}

kable(prod_fv)%>%
   kable_styling() %>%
   scroll_box(width = "900px", height = "900px")
```
